# 자료구조

## ****배열 (Array)****

- **선언할 때 크기와 데이터 타입을 지정**
- index로 빠르게 값을 찾는 것이 가능함 Big-O(1)
- 삽입 삭제 O(n)

## ArrayList

- **크기를 정해주지 않아도 된다**.
- index를 가지고 있으므로 검색도 빠르다.
- 데이터를 찾는데 빠르지만, 삽입 및 삭제가 느림

## 연결 리스트(Linked List)

- **한 노드에 연결될 노드의 포인터 위치를 가리키는 방식**
- 삭제와 삽입을 O(1) 근데 찾고 지워야 해서 O(n)
- Search 과정에 있어서 첫번째 원소부터 다 확인해봐야 한다 O(n)

## 스택 & 큐

### 스택

- 선형 자료구조의 일종
- ****LIFO (Last In First Out, 후입선출) : 가장 나중에 들어온 것이 가장 먼저 나옴****
- ***언제 사용?*** 함수의 콜스택, 문자열 역순 출력, 연산자 후위표기법

### 큐

- 선형 자료구조의 일종
- ****FIFO (First In First Out, 선입선출) : 가장 먼저 들어온 것이 가장 먼저 나옴****
- ***언제 사용?*** 버퍼, 마구 입력된 것을 처리하지 못하고 있는 상황, BFS
- 일반 큐의 단점 : 큐에 빈 메모리가 남아 있어도, 꽉 차있는것으로 판단할 수도 있음
    - (rear가 끝에 도달했을 때)
- 이를 개선한 것이 **'원형 큐'**
    - 논리적으로 배열의 처음과 끝이 연결되어 있는 것으로 간주함!
    - 원형 큐의 단점 : 메모리 공간은 잘 활용하지만, 배열로 구현되어 있기 때문에 큐의 크기가 제한
- 이를 개선한 것이 '연결리스트 큐'
    - **연결리스트 큐는 크기가 제한이 없고 삽입, 삭제가 편리**

## 힙(Heap)

- 배열에 기반한 완전 이진 트리의 일종,여러 값 중, 최대값과 최소값을 빠르게 찾아내도록 만들어진 자료구조(`최대힙(max heap)`, `최소힙(min heap)`)
- 힙은, 우선순위 큐(데이터들이 우선순위를 가지고 있음)를 위해 만들어진 자료구조다.
- **언제 사용?** 시뮬레이션 시스템, 작업 스케줄링, 수치해석 계산
- 삽입 : O(logn) , 삭제 : O(logn)

**힙의 삽입**

1.힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 삽입

2.새로운 노드를 부모 노드들과 교환

**힙의 삭제**

1.최대 힙에서 최대값은 루트 노드이므로 루트 노드가 삭제됨 (최대 힙에서 삭제 연산은 최대값 요소를 삭제하는 것)

2.삭제된 루트 노드에는 힙의 마지막 노드를 가져옴

3.힙을 재구성

## 트리(Tree)

트리는 값을 가진 `노드(Node)`와 이 노드들을 연결해주는 `간선(Edge)`으로 이루어져있다.

**트리 특징**

- 트리에는 사이클이 존재할 수 없다.
- 모든 노드는 자료형으로 표현이 가능하다.
- 루트에서 한 노드로 가는 경로는 유일한 경로 뿐이다.
- 노드의 개수가 N개면, 간선은 N-1개를 가진다.

****트리 순회 방식****

- ****전위 순회(pre-order): Root → 왼쪽 자식 → 오른쪽 자식****
- ****중위 순회(in-order): 왼쪽 자식 → Root → 오른쪽 자식****
- ****후위 순회(post-order): 왼쪽 자식 → 오른쪽 자식 → Root****
- ****레벨 순회(level-order): 루트(Root)부터 계층 별로 방문하는 방식이다.****

## 이진 탐색 트리

이진탐색 : **탐색에 소요되는 시간복잡도는 O(logN)**, but 삽입,삭제가 불가능

연결리스트 : **삽입, 삭제의 시간복잡도는 O(1)**, but 탐색하는 시간복잡도가 O(N)

이 두가지를 합하여 장점을 모두 얻는 것이 **'이진탐색트리'**

**특징**

- 각 노드의 자식이 2개 이하
- 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 큼
- 중복된 노드가 없어야 함→검색 목적
- **'중위순회(inorder)' 방식 (왼쪽 - 루트 - 오른쪽)**
- 균등 트리 : 노드 개수가 N개일 때 O(logN)
- 편향 트리 : 노드 개수가 N개일 때 O(N)

## B Tree & B+ Tree

### B Tree

이진 트리를 확장해서, 더 많은 수의 자식을 가질 수 있게 일반화 시킨 것이 B-Tree

데이터베이스, 파일 시스템에서 널리 사용

### B+ Tree

데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드(not Leaf)가 추가로 있음

B-Tree의 변형 구조로, index 부분과 leaf 노드로 구성된 순차 데이터 부분으로 이루어진다. 인덱스 부분의 key 값은 leaf에 있는 key 값을 직접 찾아가는데 사용함.

**장점**

블럭 사이즈를 더 많이 이용할 수 있음 (key 값에 대한 하드디스크 액세스 주소가 없기 때문)

leaf 노드끼리 연결 리스트로 연결되어 있어서 범위 탐색에 매우 유리함

**단점**

B-tree의 경우 최상 케이스에서는 루트에서 끝날 수 있지만, 

B+tree는 무조건 leaf 노드까지 내려가봐야 함

### **B-Tree & B+ Tree**

- B-tree는 각 노드에 데이터가 저장됨
- B+tree는 index 노드와 leaf 노드로 분리되어 저장됨
- (또한, leaf 노드는 서로 연결되어 있어서 임의접근이나 순차접근 모두 성능이 우수함)
- B-tree는 각 노드에서 key와 data 모두 들어갈 수 있고, data는 disk block으로 포인터가 될 수 있음
- B+tree는 각 노드에서 key만 들어감. 따라서 data는 모두 leaf 노드에만 존재
- B+tree는 add와 delete가 모두 leaf 노드에서만 이루어짐

## 해시(Hash)

데이터를 효율적으로 관리하기 위해, 임의의 길이 데이터를 고정된 길이의 데이터로 매핑하는 것

**해시 테이블 쓰는 이유**

- 적은 자원으로 많은 데이터를 효율적으로 관리
- 무한한 데이터들을 유한한 개수의 해시값으로 매핑하면 작은 메모리로도 프로세스 관리가 가능
- 언제나 동일한 해시값 리턴, index를 알면 빠른 데이터 검색이 가능
- 해시테이블의 시간복잡도 O(1)

 **'collision' 현상**

- 데이터가 많아지면, 다른 데이터가 같은 해시 값으로 충돌나는 현상이 발생함
- **충돌 문제 해결**
    1. **체이닝** : 연결리스트로 노드를 계속 추가해나가는 방식 (제한 없이 계속 연결 가능, but 메모리 문제)
    2. **Open Addressing** : 해시 함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장할 수 있도록 허용 (해당 키 값에 저장되어있으면 다음 주소에 저장)
    3. **선형 탐사** : 정해진 고정 폭으로 옮겨 해시값의 중복을 피함
    4. **제곱 탐사** : 정해진 고정 폭을 제곱수로 옮겨 해시값의 중복을 피함

## 트라이(Trie)

문자열에서 검색을 빠르게 도와주는 자료구조

[https://gyoogle.dev/blog/computer-science/data-structure/B Tree & B+ Tree.html](https://gyoogle.dev/blog/computer-science/data-structure/B%20Tree%20&%20B+%20Tree.html)