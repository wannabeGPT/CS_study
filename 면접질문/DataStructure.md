# 자료구조 (Data Structure)

## Array와 LinkedList의 차이점에 대해 설명해주세요.

### Array

- 접근
    - 랜덤 접근을 지원하기 때문에 index를 통해 직접적으로 접근할 수 있다.
        - 시간복잡도 : O(1)
- 삽입, 삭제
    - Array는 한 번 할당되고 나면 크기와 길이를 바꿀 수 없다.
        - 삽입 : 새로운 값을 삽입하기 위해서는 삽입할 위치를 찾은 뒤 자리 확보를 위해서 뒤에 있는 값들을 한 칸씩 밀어줘야 한다. 하지만, 배열의 크기는 바꿀 수 없기 때문에 현재 배열 크기보다 1 큰 새로운 배열을 선언해준 뒤 원소를 복사해줘야 한다.
            - 시간복잡도 : O(n)
        - 삭제 : i번째 원소를 삭제하기 위해서는 삭제할 값 뒤에 있는 모든 원소들을 앞으로 한 칸씩 땡겨서 빈자리를 채워야 한다.
            - 시간복잡도 : O(n)
- 메모리 할당
    - static memory allocation : 배열은 선언되자마자 컴파일 타임에 스택 영역에 할당이 이루어진다. 메모리 공간에 연속적으로 할당된다.

### LinkedList

- 접근
    - 랜덤 접근 방식이 아닌 순차 접근을 지원한다. 따라서, 어떤 요소에 접근할 때 순차적으로 접근하면서 찾아야 한다.
        - 시간복잡도 : O(n)
- 삽입, 삭제
    - Array와 달리 LinkedList는 동적 배열이기 때문에 배열의 크기를 바꿀 수 있다.
        - 삽입 : 정적 배열과 달리 삽입하고 싶은 위치를 찾은 뒤 새로운 값을 바로 삽입할 수 있다.
            - 시간복잡도 : O(1)
        - 삭제 : 삽입과 동일하게 삭제하고 싶은 위치를 찾은 뒤 해당 값을 바로 삭제할 수 있다.
            - 시간복잡도 : O(1)
- 메모리 할당
    - dynamic memory allocation : 새로운 노드가 추가될 때 런타임에 힙 영역에 할당된다.

어떤 상황에서 사용하는 것이 좋은가

- Array : 데이터 수정이 적고 조회가 많은 경우
    - 주식차트, 날씨정보, 시청률 등 삽입, 삭제가 많지 않고 (과거의 데이터) index 순서를 보장해야 하는 데이터들
- LinkedList : 데이터 수정이 많은 경우
    - 휴대폰 전화번호부 등

## Stack과 Queue의 차이점에 대해 설명해주세요.
### Stack
- LIFO 구조. 삽입/삭제가 한 방향에서 이루어짐.
- 사용 예시 : 함수 콜스택, 문자열 역순 출력, 연산자 후위표기법 등

### Queue
- FIFO 구조. 삽입/삭제가 양 방향에서 이루어짐.
- 사용 예시 : 버퍼, 프린터 큐 등

## Queue를 일반 배열로 구현할 경우 발생하는 문제점에 대해 설명해주세요.
![image](https://user-images.githubusercontent.com/58061756/216308862-7f3e033b-85c0-4da8-90d6-94e92c629a36.png)

- 6의 용량을 가진 큐가있다고 가정했을때, 제거 연산을 수행할 때 마다 용량이 줄어들게 된다. (배열의 첫 번째 원소가 못쓰는 칸이 되기 때문에) 따라서 큐를 일회성으로밖에 사용하지 못한다.
- 그렇지만, 위 상황을 막기 위해 아래처럼 제거 연산 후 하나씩 옆으로 옮기기에는 비용이 너무 크게 발생한다.

![image](https://user-images.githubusercontent.com/58061756/216308898-5f5e8b8d-3e34-498b-95bc-de9864f22460.png)

- 이 문제를 해결하려면 큐의 시작과 끝을 연결해서 순환할 수 있는 순환 큐(Circular Queue)로 만들면 된다.
- 아래처럼 순환큐(원형 큐)를 만들면 제거연산 후에도 같은 용량을 가질 수 있다.

![image](https://user-images.githubusercontent.com/58061756/216308896-7c781d4d-6bd6-429a-acac-a2b04e0e1498.png)



## Stack을 Linked List로 구현할 경우 Head에서 push(), pop()을 진행합니다. Head가 아닌 Tail에서 진행하면 안되는 이유가 무엇일까요?
단방향 Linked List(싱글 연결 리스트)의 경우 각 노드의 다음 노드를 가리키는 포인터만을 가진다.

- Tail에서 push(), pop()을 하는 경우의 시간복잡도 O(N) : 예를 들어 pop()을 진행한 후에는 tail 이 기존이 가리키던 노드 그 앞 노드를 가리켜야 하는데 그러기 위해서는 head에서 부터 순차적으로 tail 바로 앞까지 가기 위해 O(N)의 시간이 걸린다. 
- Head에서 pop()을 한 후에 head가 그 다음 노드를 가리키기 위해서는 O(1)의 시간만 필요하기 때문에 Head에서 연산을 수행한다.

-> 위의 문제점은 doubly linked list를 사용하는 경우 각 노드의 앞(prev), 뒤(next)를 가리키는 포인터를 모두 가지므로 해결 가능하다.


## 힙의 삽입과 삭제 과정을 설명해주세요.

## 트리와 그래프의 차이를 설명해주세요.

## 그래프에서 인접 행렬과 인접 리스트 중 어떤 경우에 무엇을 사용하는 것이 유리한지 장단점을 비교하여 설명해주세요.

## 트리와 이진 탐색 트리의 차이를 설명해주세요.

## B-Tree와 B+Tree의 특징

## 대량의 데이터를 탐색할 때 B+-Tree가 BST보다 효과적인 이유는 무엇인가? (DB에서 B+-Tree를 사용함)

## B+-Tree를 사용하여 데이터 탐색을 할 경우 Disk I/O가 적은 이유는?

## Hash를 사용하는 이유는?

## Hash 충돌을 해결하는 방법은 무엇인가요?

## 해시 테이블은 어떤 방식으로 조회에 시간복잡도 O(1)을 보장하나요?


## Trie가 무엇인지, 어디에 주로 사용되는지 설명해주세요.


