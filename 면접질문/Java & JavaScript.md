# Java & JavaScript

## Java

### **객체지향과 절차지향의 차이에 대해서 말해주세요.**

* 절차지향언어 - 개체를 순차적으로 처리하는 절차지향 프로그래밍에 쓰이는 언어이고 대표적으로 c언어가 있다.
* 객체지향언어 - 데이터를 추상화 시켜 상태와 행위를 가진 객체로 만들고 이들끼리 서로 상호작용하도록 만드는 언어이고 대표적으로 java와 c++이 있다.

---

절차지향과 객체지향의 차이점으로는 
1. 구성요소가 함수 / 객체 이다.
2. 접근제어자가 존재하지 않고 / 존재한다.
3. 오버로딩, 상속이 불가능하고 / 가능하다
4. 절차지향의 경우 프로젝트가 커지면 복잡도가 증가하고 중복 코드 문제가 발생할 수 있다. 객체지향의 경우 객체 기능에서 발생하는 오버헤드를 최적화할 수 없다면 상대적으로 느려진다.
<br/><br/><br/>   


### **객체지향 언어 (OOP)의 특징을 설명해주세요.**

> OOP is A PIE

- 캡슐화 (Encapsulation)
    
    서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호
    
    데이터 보호, 데이터 은닉
    
    - 구현 방법 : 접근 제어자, getter/setter
- 상속 (Inheritance)
    
    기존의 클래스를 재활용하여 새로운 클래스를 작성하는 것
    
- 다형성 (Ploymorphism)
    
    어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질
    
    overriding, overloading
    
- 추상화 (Abstraction)
    
    객체의 공통적인 속성과 기능을 추출하여 정의하는 것
    
    불필요한 세부 사항들은 제거하고 가장 본질적
    

→ 이 모든 특징은 결합도를 낮추고 재사용성과 유지보수를 높이기 위한 특징!!
<br/><br/><br/>  

### **객체지향의 설계원칙에 대해 설명해주세요.**
앞글자를 따서 SOLID 원칙이라고도 한다.
1. 단일 책임 원칙 (Single Responsibility Principle)   
   모든 클래스는 각각 하나의 책임만 가져야 한다. 클래스는 그 책임을 완전히 캡슐화해야 함을 의미한다.

2. 개방-폐쇄 원칙 (Open Closed Principle)   
   확장에는 열려있고 수정에는 닫혀있는 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 한다는 원칙.

3. 리스코프 치환 원칙 (Liskov Substitution Principle)   
   자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다는 원칙이다.

4. 인터페이스 분리 원칙 (Interface Segregation Principle)   
   한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않아야 한다.

5. 의존 역전 원칙 (Dependency Inversion Principle)   
   의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존해야 한다는 원칙

<br/><br/><br/>  

### **Java의 메모리영역에 대해 설명해주세요. 각 메모리 영역이 할당되는 시점은 언제인가요?**
* java의 메모리 영역은 method area / stack / heap 3부분으로 이루어져있다.
* `method area`에는 클래스 변수와 메소드가 저장된다.   
  method area는 프로그램의 시작부터 종료까지 메모리에 할당된 상태이다. 
* `stack` 에는 primitive 타입 데이터에 해당되는 지역변수와 매개 변수 데이터 값이 저장된다.   
  stack은 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리에서 사라진다.
* `heap`에는 Reference 타입 데이터를 갖는 객체나 배열이 저장된다.   
  해당 개체가 호출될 때 메모리에 할당되지만 stack과는 다르게 호출이 끝나도 삭제되지 않고 유지된다.
  어떤 참조 변수도 heap영역의 인스턴스를 참조하지 않게 된다면 가비지 컬렉터에의해 메모리에서 사라진다.


### **JVM의 역할에 대해 설명해주세요.**
* JVM은 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행한다.   
  독립적으로 작동하며 Java와 OS 사이에서 중개자 역할을 수행하여 Java가 OS에 구애받지 않는다.
  수행하는 중요한 기능에는 메모리 관리, 가비지 컬렉션이 있다.


### **가비지 컬렉션에 대해 설명해주세요. 가비지 컬렉션 과정에 대해 설명해주세요.**
* 가비지 컬렉션은 자바의 메모리 관리 방법 중의 하나로 Heap 영역에서 동적으로 할당했던 메모리 영역 중 필요 없게 된 메로리 영역을 주기적으로 삭제하는 프로세스를 뜻한다.

![Garbage Collection](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FoGHFh%2Fbtrw5CmjupT%2FqKKpeC0UzzbCGYmoGjI3Bk%2Fimg.png)
1. 객체가 처음 생성되고 Heap의 Eden에 `age-bit 0으로 할당`된다. Minor GC에서 살아남을 때마다 age-bit는 1씩 증가한다.
2. Heap의 Eden 영역에 객체가 다 쌓이게 되면 `Minor GC`가 한 번 일어나게 되고 참조 정도에 따라 Survivor0 영역으로 이동되거나 회수된다.
3. 계속해서 eden 영역에 신규 객체가 생성되어 다 쌓이게 되면 `Young generation` (eden + survivor0)영역에 있는 객체들을 비어있는 survivor1 영역으로 이동시키고 age-bit를 1씩 증가시킨다.
4. 또 다시 eden 영역에 신규 객체들로 가득차면 Minor GC가 일어나고 이번에는 비어있는 survivor0 영역으로 이동시킨 뒤 age-bit를 1 증가시킨다. 이 과정을 반복한다.
5. 이 과정을 반복하다 JVM에 설정된 age bit에 도달한 객체는 `Old generation` 영역으로 이동시킨다. 이 과정을 `프로모션`이라고 한다.
6. Old generation에 할당된 메모리가 허용치를 넘어서면 이 영역안의 모든 객체를 검사해서 참조되지 않는 객체들을 한번에 삭제하는 `Major GC`가 실행된다. 이 작업이 너무 잦으면 프로그램 성능에 문제가 생긴다.

<br/><br/><br/>  

### **오버로딩(Overloading)과 오버라이딩(Overriding)의 차이에 대해서 설명해주세요.**
* 오버로딩(Overloading)은 기존에 존재하는 메서드의 이름과 같은 새로운 메서드를 다른 매개변수 조건으로 정의하는 것이고,
* 오버라이딩(Overriding)은 상속 받은 메서드의 내용만 변경 하는 것이다.   

오버라이딩과 오버로딩의 차이점
|구분|Overriding|Overloading|
| --- | --- | --- |
| 접근 제어자 | 부모 클래스의 메소드의 접근 제어자보다 자식 클래스 의 접근 제어자가 `더 넓은 범위` 를 가져야 한다. | `모든 접근 제어자`  사용 가능 |
| 리턴형 | 동일  | 달라도 됨 |
| 메소드명 | 동일  | 동일  |
| 매개변수 | 동일  | 달라야 됨 |
| 적용 범위 | `상속관계` 에서 적용된다. | `같은 클래스 내` 에서 적용된다. |

오버라이딩의 조건
- 메서드 이름, 매개 변수(개수, 타입, 순서), 리턴 타입이 같아야 함
- 접근 제한자는 부모보다 범위가 넓거나 같아야 함
- 조상보다 더 큰 예외를 던질 수 없음
- static 메서드는 오버라이딩 불가능

<br/><br/><br/>  

### **String이 아닌 StringBuilder나 StringBuffer를 사용하는 상황은?**
* String 클래스는 `immutable` 하다.
* String 끼리 '+' 연산을 할 경우 두 문자열을 모두 읽어 들여 새로운 메모리에 복사하기 때문에 성능 메모리가 낭비된다.
* 따라서 이런 상황에서 StringBuilder나 StringBuffer를 사용한다.

### **StringBuilder와 StringBuffer의 차이는?**
* StringBuffer와 StringBuilder 모두 제공하는 메서드는 동일하며 버퍼 크기를 늘리면서 유연하게 동작한다.
하지만 동기화 여부에서 차이가 난다. StringBuffer는 멀티스레드 환경에서 동기화를 지원하지만 StringBuilder는 동기화를 보장하지 않는다.

<br/><br/><br/>  

### **클래스와 객체에 대해 설명해주세요.**
* 클래스는 객체를 만들어내기 위한 설계도 혹은 틀 이라고 할 수 있고, 객체를 생성하는데 사용합니다.
* 객체는 설계도(클래스)를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖습니다.
  여기서 상태는 필드(fields), 행동은 메소드(Method)라고 표현합니다.
  객체에 메모리가 할당되어 실제로 활용되는 실체는 '인스턴스'라고 부릅니다.

### **Wrapper Class란 무엇이며, Boxing과 Unboxing은 무엇인지 설명해주세요.**
* 기본 자료형(Primitive data type)에 대한 객체 표현을 Wrapper class라고 합니다.
  기본 자료형 → Wrapper class로 변환하는 것을 Boxing이라 하며,
  Wrapper class → 기본 자료형으로 변환하는 것을 UnBoxing이라 합니다.

### **추상클래스와 인터페이스의 차이에 대해 설명해주세요.**
* 추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우를 말하고,
인터페이스는 모든 메소드가 추상 메소드로만 이루어져 있는 것을 말합니다.
    - 공통점
        - new 연산자로 인스턴스 생성 불가능
        - 사용하기 위해서는 하위 클래스에서 확장/구현 해야 한다.
    - 차이점
        - 인터페이스는 그 인터페이스를 구현하는 모든 클래스에 대해 특정한 메소드가 반드시 존재하도록 강제함에 있고,
        - 추상클래스는 상속받는 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용한다.
        - 추상클래스는 다중상속이 불가능하지만, 인터페이스는 다중상속이 가능하다.
<br/><br/><br/>  

### **Error와 Exception의 차이를 설명해주세요.**
* Error는 컴파일 시 개발자가 대처하기 어려운 프로세스 종료를 야기할 수 있는 심각한 문제를 뜻하고
* Exception은 개발자가 구현한 로직에서 발생한 실수나 사용자의 영향에 의해 발생한 예기치 않았던 이상 상태가 발생해서 수행중인 프로그램이 영향을 받는 것을 뜻한다. 개발자가 미리 예측해서 방지할 수 있다.

### **CheckedException과 UnCheckedException의 차이를 설명해주세요.**
* Checked Exception은 예외처리가 필수이고 처리하지 않으면 컴파일되지 않는다.   
  RuntimeException 외의 IOException, SQLException 등이 이에 속한다.
* Unchecked Exception은 컴파일 때 체크되지 않고 Runtime에 발생하는 Exception을 말한다.  
  RuntimeException 하위의 NullpointerException, IndexOutOfBoundException 등이 이에 속한다.

<br/><br/><br/>  

## JavaScript

### **null과 undefined, undeclared, NaN의 차이에 대해 설명해주세요.**
* null은 null 값이 명시적으로 할당된 상태이다.
* undefined는 선언되었지만 값이 할당되지 않은 변수이다.
* undeclared는 선언되지 않은 식별자에 값을 할당할 때 생성된다.
* NaN은 컴퓨터 시스템이 숫자로 표현할 수 없는 상태이다.

### **호이스팅에 대해 설명해주세요.**
* 호이스팅이란 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미한다.   
  Javascript는 모든 선언문이 선언되기 이전에 참조가 가능하다. 
  즉, var 키워드를 통해 선언한 변수나 function 선언문이 해당 scope의 처음으로 옮겨진 것처럼 동작하는 특성을 뜻한다.

### **var, let, const 로 선언된 변수를 호이스팅하면 어떤 일이 벌어질까요?**
* 공통적으로 선언이 해당 scope 최상단으로 끌어올려진다.
* var의 경우는 선언과 함께 undefined로 초기화가 되지만 let과 const는 초기화 되지 않는다.
* 따라서 세 경우 모두 선언이 끌어올려져 호이스팅은 일어나지만 let과 const의 경우 초기화 되지 않은 상태로 참조되므로 참조에러가 발생한다.